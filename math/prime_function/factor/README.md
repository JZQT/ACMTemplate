# 分解质因数

---

## 概述

根据**算术基本定理**，任何一个大于$1$的自然数都能被分解成有限个质数的乘积。
所以任何大于$1$的自然数我们都可以对它进行分解质因数。

对一个大于$1$的自然数数进行分解质因数我们可以得到这个数的**质因数个数**，**质因数种数**以及**每种质因数出现的次数**等信息。

## 实现

假设要对自然数$n$进行分解，直观的想法可能是先获取$[2, n]$范围内的素数，然后从小到大依次对$n$进行分解。

```cpp
int primes[N], pn;  // 已经筛出来的[2, n]范围内的素数表

int Factor(int n)   // 该函数返回n分解后的质因数种数，比如4 = 2 × 2，只有一种质因数2，返回1
{
    int res = 0;
    for (int i=0; i<pn; ++i)
    {
        if (n % primes[i] == 0)
        {
            res++;
            while (n % primes[i] == 0) n /= primes[i];
        }
        if (n == 1) break;
    }
    return res;
}
```

不过，很显然：**大于$1$的自然数$n$分解质因数后大于$\sqrt n$的质因数不会超过一个**。

假设大于$1$的自然数$n$有分解后有两个大于$\sqrt n$的质因数$x$和$y$，
那么很明显$x * y > \sqrt n * \sqrt n = n$与条件冲突。

所以我们并不需要$[2, n]$范围内的素数，只需要$[2, \sqrt n]$范围内的素数就好。

```cpp
int primes[N], pn;  // 已经筛出来的[2, sqrt(n)]范围内的素数表

int Factor(int n)   // 该函数返回n分解后的质因数种数，比如4 = 2 × 2，只有一种质因数2，返回1
{
    int res = 0;
    for (int i=0; i<pn; ++i)
    {
        if (n % primes[i] == 0)
        {
            res++;
            while (n % primes[i] == 0) n /= primes[i];
        }
        if (n == 1) break;
    }
    if (n > 1) res++;   // 很明显这是大于sqrt(n)的n的质因数
    return res;
}
```

其实，筛素数并不是分解质因数的一个必要的做法，对于一个自然数$n$，我们可以直接枚举大于$1$小于$\sqrt n$的自然数来分解。

```cpp
int Factor(int n)   // 该函数返回n分解后的质因数种数，比如4 = 2 × 2，只有一种质因数2，返回1
{
    int res = 0;
    int cnt = (int)sqrt(n + 0.5) + 1;
    for (int i=2; i<cnt; ++i)
    {
        if (n % i == 0)
        {
            res++;
            while (n % i == 0) n /= i;
        }
        if (n == 1) break;
    }
    if (n > 1) res++;       // 这个地方是分解质因数代码经常漏写的一个地方
    return res;
}
```

偷个懒，为什么可以这么写分解质因数的代码，我就不写了，有兴趣的读者可以自己好好思考一下。
另外，上述的代码只能实现返回被分解数分解后的质因数的种数。
实际上把代码扩展一下还可以实现获得分解后**质因数的个数**，**质因数表**，以及**每种质因数出现的次数**等。
请自行思考代码实现。
