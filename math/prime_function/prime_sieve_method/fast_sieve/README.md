# 快速线性筛法

## 概述

**快速线性筛法**是一种基于埃氏筛法的改进筛法，**时间复杂度为O(n)**，因此也叫做**线性筛法**。

## 原理

**埃氏筛法的原理是利用每一个数除了1和它本身的因数来筛素数。**
因为每一个数可能有很多除了1和它本身的因数，因此在埃氏筛法中，每一个合数都可能被筛去多次。
要使得算法的时间复杂度为线性，那么要求每一个合数都应该只被筛去一次。
**快速线性筛法的原理是利用每一个数的最小素因子来筛素数。**
每一个数的最小素因子都只有一个，这就使得每一个合数都只可能被筛去一次，大大提高了筛法的效率。
**值得一提的是，在快速筛法的代码实现中，开素数表的空间是必要的，因为筛素数需要利用已经筛出来的素数表。**

## 实现

快速线性筛法的代码实现稍微有些晦涩难懂，代码如下
```cpp
bool isprime[N];        //判断是否为素数
int primes[N], pn;      //素数表及素数个数

void FastSieve(int maxn)    //筛[0,maxn]区间的素数
{
    memset(isprime, true, sizeof(isprime));
    isprime[0] = isprime[1] = true;
    pn = 0;
    for (int i=2; i<=maxn; ++i)
    {
        if (isprime[i]) primes[pn++] = i;
        for (int j=0; j<pn; ++j)
        {
            if (i * primes[j] > maxn) break;    //判断是否越界
            isprime[i * primes[j]] = false;
            if (i % primes[j] == 0) break;      //利用最小素因子筛素数的关键
        }
    }
    return;
}
```
快速线性筛法是外层循环枚举`倍数`，内层循环枚举`素数`。然后通过`素数×倍数=合数`来筛素数。
由于是采用最小素因子来筛素数，因此就要保证枚举的`素数`是`合数`的最小素因子。
如果`倍数`没有比`素数`更加小的素因子，那么`合数`的最小素因子就是`素数`。
在快速线性筛法的代码实现中的关键代码里，如果`i % primes[j] == 0`，说明**当前**`primes[j]`是`i`的最小素因子。
由于素因子的枚举是从小到大的，因此如果不`break`的话继续循环后`倍数i`就有了比`素数primes[j]`更小的素因子。
