# 欧几里德算法及其扩展

## 欧几里德算法

### 概述
欧几里德算法又称为**辗转相除法**，用于计算两个**正整数**的**最大公约数**。

因欧几里德算法用于求最大公约数(greatest common divisor)，故常用`gcd`来表示。

用`gcd(a, b)`来表示a和b的最大公约数，那么欧几里德算法的计算原理依赖与下面的定理
```cpp
gcd(a, b) == gcd(b, a % b);     //a > b && a % b != 0
```
因此计算两个正整数的最大公约数的欧几里德算法函数可以这么写
```cpp
int Gcd(int a, int b)
{
    return b == 0 ? a : Gcd(b, a % b);
}
```

欧几里德算法还可用于计算**最小公倍数**(least common multiple)，用`lcm`来表示，其原理基于
```cpp
lcm(a, b) == a * b / gcd(a, b); //a > b && a % b != 0
```
因此计算两个正整数的最小公倍数的函数可以这么写
```cpp
int Lcm(int a, int b)
{
    return a / Gcd(a, b) * b;
}
```
**注意：先除后乘是为了避免数据范围溢出，由于`Gcd(a, b)`是最大公约数，因此除法必能整除。**

## 扩展欧几里德算法

### 概述

扩展欧几里德算法是欧几里德算法的扩展。

它可以在求出a、b的最大公约数的同时，找到满足等式`ax + by = gcd(a,b)`的一对整数解x、y(可能有负数)。

这里给出这样一个基本的事实：**如果给予两个整数a、b，那么必然存在整数x、y使得`ax + by = gcd(a,b)`。**

**原理**：有两个数a和b，对它们进行辗转相除法，可以得到它们的最大公约数。收集辗转相除法中产生的式子，倒回去，就可以得到`ax + by = gcd(a,b)`的整数解了。
