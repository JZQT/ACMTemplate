# 乘法逆元

## 概述

**乘法逆元**的概念相当于**倒数**，`a`除以`b`相当于乘上`b`的倒数，因此`b`的倒数与`b`互为乘法逆元。
同样我们也可以推广到**加法逆元**，它的概念相当于**相反数**。`a`加上`b`相当于加上`b`的相反数，因此，`b`的相反数与`b`互为加法逆元。

但是，接下来我们要说的**乘法逆元**中的**乘法**不是普通的乘法，而是**模乘法**。

在完全剩余系Zn下的两个元素`a`和`b`如果满足`a × b = 1`，比如说在Z9中`2 × 5 = 1`，那么`a`和`b`互为模n下的乘法逆元。

## 求解

计算一个整数`a`在模`m`下的乘法逆元(**可能不存在**)，相当于求`ax = 1(mod m)`的最小正整数解。

这里有两种方法可以求出乘法逆元，**两种方法的时间复杂度几乎一样**。

* 利用**扩展欧几里德算法**计算

    求整数`a`在模`m`的乘法逆元，即求`ax = 1(mod m)`的最小正整数解。
    如果这样的解存在的话，那么相当于存在整数`k`使得`ax = 1 + mk`，根据**求模运算**的性质，你也可以写成`ax = 1 - mk`，这样变型后得`ax + mk = 1`。
    这个式子明显可以使用**扩展欧几里德算法**进行求解。
    根据**二元一次不定方程整数解的性质**我们也可以很容易知道**当且仅当`a`和`m`互素时存在`a`在模`m`的乘法逆元**。

    下面给出求解乘法逆元的样例代码，假设存在乘法逆元
    ```cpp
    int Inverse(int a, int m)   //不存在乘法逆元返回0
    {
        int x, y;
        return ExGcd(a, m, x, y) == 1 ? (x % m + m) % m : 0;
    }
    ```

* 利用**欧拉定理**及**欧拉函数**进行计算
